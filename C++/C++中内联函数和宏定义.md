# C++中内联函数和宏定义

## 1.内联函数针对的对象

​	一般来说内联机制用于优化规模较小、流程直接、频繁调用的函数。

## 2.为什么要将函数设置为内联函数

​	内联函数可避免函数调用的开销。调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复，可能需要拷贝实参、程序转向一个新的位置继续执行。将函数指定为内联函数（inline)通常就是将它在每个调用点上内联的展开。

​	内联函数的优点：

1. 有参数类型检测，更加安全
2. 内联函数是在程序运行时展开，而且是进行参数传递
3. inline关键字只是对编译器的一个定义，如果函数本地不符合内联函数的标准，编译器就会将这个函数当作是普通函数

   内联函数的缺点：会使代码变长，占用更多的内存

## 3.和宏定义的比较

reference：[内联函数和宏定义的优劣及其区别](https://www.cnblogs.com/yinbiao/p/11606554.html)

- 宏定义：#define

  好处：使用预处理器实现，没有了参数压栈，代码生成等一系列操作，效率高

  缺点：1.不能进行参数有效性的检测，也不能享受C++编译器严格类型检查的好处，返回				值也不能被强制转换为可转换的合适类型

  ​			2.不能访问类的成员变量

  ​			3.使用参数时，是严格的替换策略，无论你的参数是何种形式，在展开中都是用				形参数代替实参，这样宏定义容易产生二义性，存在一系列的隐患。

- 宏定义和内联函数的主要区别：
  1. 内联函数在运行时可以调试，而宏定义不行
  2. 编译器会对内联函数的参数类型做安全检查，或自动类型转换，而宏定义则不会
  3. 内联函数可以访问类的成员变量，而宏定义则不能

## 4.内联函数示例：

```cpp
#include<iostream>
using namespace std;

inline int bigger(int a,int b){
    return a > b?a:b;
}
int main(){
    int bigger_num = bigger(10,5);
    cout << bigger_num << endl;
    return 0;
}
```

## 5.宏定义示例

```cpp
#include<iostream>
using namespace std;
#define bigger(a,b) a > b ? a: b
int main(){
    int bigger_num = bigger(10,5);
    cout << bigger_num <<endl;
    return 0;
}
```

