# C++面试准备

## 第一部分：C++基础

### 1.1基础知识

1. static

   - 全局静态变量：静态存储区，在整个运行期间一直存在。未经初始化的全局静态变量会自动初始化为0。作用域，在声明他的文件之外是不可见的，准确的说是从定义之处开始，到文件结尾。
   - 局部静态变量：静态存储区，未经初始化的局部静态变量会被自动初始化为0，作用域认为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存里，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。
   - 静态函数：只在声明它的文件当中可见。不能被其他文件所用。
   - 类的静态成员：在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态成员中存储一处，工所有对象使用。
   - 类的静态函数：属于类的静态成员，它们不是对象成员。因此，对静态成员的引用不需要使用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

2. C++和C的区别

   |       区别       |      C++       |            C             |
   | :--------------: | :------------: | :----------------------: |
   |     设计思想     | 面向对象的语言 | 面向过程的结构化编程语言 |
   |     范式编程     |      支持      |          不支持          |
   | 重载、继承、多态 |      支持      |          不支持          |

   C++相比C还增加了许多类型安全的功能，比如强制类型转换

3. C++中四种cast转换

   |       类型       |                             功能                             |
   | :--------------: | :----------------------------------------------------------: |
   |    const_cast    |                 用于将const变量转换为非const                 |
   |   static_cast    | 用于各种隐式转换，比如非const转const，void*转指针等，static_const能用于多态向上转化，如果向下转能成功，但是不安全，结果未知 |
   |   dynamic_cast   | 用于动态类型转换。只能用于含有虚函数的类，用于类层次的向上和向下转化。只能转指针或引用，向下转化时，如果是非法的，对于指针返回NULL，对于引用抛出异常。 |
   | reinterpret_cast |   几乎什么都可以转，比如将int转指针，可能会出错，尽量少用    |

   为什么不用C的强制转换：转化不明确，不能进行错误检查，容易出错。

4. 指针和引用：
   - 指针有自己的一块地址，而引用只是一个别名
   - 使用sizeof，对于指针的大小是4，而对于引用是被引用对象的大小
   - 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用
   - 作为参数传递时，指针需要被解引用才可以对对象进行操作，而引用则可以直接对引用操作。
   - 可以有const指针，但是没有const引用
   - 指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变
   - 指针可以有多级指针，但是引用只能一级
   - 指针和引用使用++运算符意义不同
   - 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏

5. 智能指针

   作用是管理一个指针，可以避免申请的空间在函数结束时忘记释放，造成内存泄漏。智能指针就是一个类，当超出了类的作用域，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存。

   - **auto_ptr:C**++98的方案，C++11已经抛弃.采用所有权模式。

     ```cpp
     auto_ptr<string> p1(new string("I reigned lonely as a cloud."));
     auto_ptr<string> p2;
     p2 = p1;//auto_ptr不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
     ```

   - **unique_ptr**:用于替换auto_ptr,实现独占式拥有或者严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。也是采用所有权模式。

     ```cpp
     unique_ptr<string> p1(new string("I reigned lonely as a cloud."));
     unique_ptr<string> p2;
     p2 = p1;//此时会报错，编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。
     ```

     unique_ptr还有更聪明的地方：当程序试图将一个unique_ptr赋值给另一个时，如果源unique_ptr是个临时右值，编译器允许这么做；如果源unique_ptr将存在一段时间，编译器将禁止这么做。

     ```cpp
     unique_ptr<string> pu1(new string("hello world!"));
     unique_ptr<string> pu2;
     pu2 = pu1;//报错，不允许，因为pu1将存在一段时间
     unique_ptr<string> pu3;
     pu3 = unique_ptr<string>(new string("You"));//允许，因为源unique_ptr在赋值结束后就销毁了
     ```

     注意：C++有一个标准库函数std::move()，可以将一个unique_ptr赋给另一个。如：

     ```cpp
     unique_ptr<string> ps1,ps2;
     ps1 = demo("hello");
     ps2 = move(ps1);
     cout << *ps2 << *ps1 <<endl;
     ```

   - shared_ptr:实现共享式拥有概念。多个智能指针可以指向同一个对象，该对象和1其相关资源会在最后一个引用被销毁时候释放。它使用计数机制来表明资源被几个指针共享。当计数等于0时，资源会被释放。

     成员函数：

     |    函数     |                        功能                        |
     | :---------: | :------------------------------------------------: |
     | use_count() |                  返回引用计数个数                  |
     |   unique    |     返回是否是独占所有权，或者是否use_count为1     |
     |    swap     |     交换两个shared_ptr对象，即交换所拥有的对象     |
     |    reset    | 放弃内部对象的所有权，会引起原有对象的引用计数减少 |
     |     get     |        返回内部对象，和直接使用对象是一样的        |

   - weak_ptr:不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象，进行该对象的内存管理的是那个强引用的shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段，协助shared_ptr工作，它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。weak_ptr是用来解决shared_ptr互相引用时的死锁问题。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以想回转换，shared_ptr可以直接赋值给它，它可以通过调用lock()函数来获取shared_ptr.

 6. 数组和指针：

    |                             指针                             |                 数组                 |
    | :----------------------------------------------------------: | :----------------------------------: |
    |                        保存数据的地址                        |               保存数据               |
    | 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 |             直接访问数据             |
    |                    通常用于动态地数据结构                    | 通常用于固定数目且数据类型相同的元素 |
    |                 通过malloc分配内存，free释放                 |           隐式的分配和删除           |
    |                通常指向匿名数据，操作匿名函数                |            自身即为数据名            |

 7. 野指针：指向一个已删除的对象或者为申请访问受限内存区域的指针。

 8. 为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？

    为什么析构函数必须是虚函数：保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

    为什么默认的析构函数不是虚函数：因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而只有当需要当父类时，设置为虚函数。

 9. 函数指针：指向函数的指针变量。用于调用函数或者做函数参数，比如回调函数。

 10. fork函数：

     可以创建一个和当前进程映像一样的进程。

     ```cpp
     #include<sys/types.h>
     #include<unistd.h>
     pid_t fork(void);
     ```

     成功调用fork()会创建一个新的进程，它几乎与调用fork()的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork()调用会返回0，在父进程中fork()返回子进程的pid。如果出现错误，fork()返回一个负值。

     最常见的用法是fork()创建一个新的进程，然后使用exec()载入二进制映像，替换当前进程映像。这种派生加执行的方式是最常见的。

 11. 静态函数和虚函数的区别：

     静态函数在编译时就已经确定运行时机，而虚函数在运行时动态绑定。虚函数因为使用虚函数表和虚表指针，所以调用的时候会增加一次内存开销。

 12. 重载和覆盖：

     重载：函数名相同，参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中。

     重写：子类继承父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况时重写。

13. C++中是怎么定义常量的？常量存放在内存的哪个位置？

    C++中定义常量是在const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局或者静态存储区。对于字面值常量，存放在常量存储区。

14. C++函数栈空间的最大值：

    默认是1M，不过可以调整。

15. |       new/delete       |                         malloc/free                          |
    | :--------------------: | :----------------------------------------------------------: |
    |       C++关键字        |                         C语言库函数                          |
    | 不需要指明内存空间大小 | 使用必须指明申请内存空间的大小，对于类的对象，不会调用类的构造函数和析构函数 |

16. RTTI：

    运行时类型检查，在C++层面主要体现在dynamic_cast和typeid，VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info.

17. C语言是怎么进行函数调用的？

    每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

18. C语言参数压栈顺序：

    从右到左

19. C++如何处理返回值

    生成一个临时变量，把它的引用作为函数参数传入函数内。

### 1.2容器和算法

1. 关联容器

$$
关联容器 \begin{cases} pair类型 \\map类型 \begin{cases}map \\ multimap \end{cases} \\set类型 \begin{cases}set \\multiset\end{cases}  \end{cases}
$$

- ​	pair类型

  ```
  定义在头文件utilty中。
  操作：
  pair<T1,T2>    p1;                     创建一个空的pair对象，它的两个元素分别是T1和T2类型，采用值初始化
  pair<T1,T2>    p1(v1,v2);              创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始									  化为v2，second成员初始化为v2。
  make_pair(v1,v2)                       以v1,v2值创建一个新的pair对象，其元素类型分别是v1，v2类型
  p1<p2                                  两个pair对象之间的小于运算，遵循字典顺序
  p1==p2                                 如果两个pair对象的first和second值依次相等，则它们相等
  p.first                                返回p中名为first的数据成员
  p.second                               返回p中名为second的数据成员
  ```

- map类型

  ```
  定义在头文件map中。
  ```

  

2.顺序容器
$$
顺序容器\begin{cases} vector \\array \\list \\deque \\ stack \\queue \\priority_queue \end{cases}
$$
​	3.泛型算法

### 1.3类和数据抽象

1. 类
2. 复制控制
3. 重载操作符和转换

### 1.4面向对象与泛型编程

1. 面向对象编程
2. 模板与泛型编程

### 1.5编译与底层

1. 编译原理
2. 底层原理与内存原理
3. 高性能 io

### 1.6 C++11

新特性

## 第二部分：计算机网络

### 2.1分层

### 2.2 运输层

1. TCP与UDP网络通信
2. 协议

### 2.3网络层

1. 网际协议IP
2. 网际控制报文协议ICMP
3. 因特网的路由器选择协议

### 2.4应用层

1. 域名系统DNS
2. 电子邮件

## 第三部分：操作系统

### 3.1进程的描述与控制（多线程）

### 3.2输入输出系统

### 3.3 存储器管理

### 3.4处理机调度与死锁

### 3.5 Linux

## 第四部分：数据库

### 4.1mysql

### 4.2 redis

## 第五部分：算法与数据结构

### 5.1树

### 5.2堆与栈

### 5.3数组

### 5.4排序

### 5.5哈希

### 5.6动态规划

### 5.7链表

### 5.8字符串

### 5.9高级算法（KMP）

## 第六部分：设计模式

### 6.1代理模式

### 6.2装饰模式

### 6.3单例模式

### 6.4工厂方法模式

### 6.5抽象工厂模式

### 6.6观察者模式



